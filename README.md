Пробки на почте
===============

Думаю, нет смысла лишний раз рассказывать про проблемы Почты России, о них и так все знают. Одной из этих проблем являются длинные очереди. У меня, при виде такой очереди иногда возникает резонная мысль "лучше бы сюда вообще не заходил", ибо на дорогу до отделения уже потрачено N минут, а в очереди стоять предстоит ещё неизвестно сколько. Беда почтовых очередей в том, что это не очередь в магазине, где можно при желании не стоять. Вместо этого можно пойти в соседний магазин и купить там то, что нужно. Письмо/посылку же в любом другом отделении получить не получится. От проблемы стояния в длинных очередях можно было бы избавиться, имея информацию о том, какова обстановка в конкретном почтовом отделении. Например, сколько там сейчас человек, сколько времени уходит на обслуживание одного человека, сколько окошек открыто и т.п. Именно этой информацией я и предлагаю делиться посредством сервиса, описанного далее.

Примеры использования
---------------------

Допустим, Вы знаете, что на почтовом участке Вас ждёт посылка(заказное-письмо/что-то-ещё), осталось только прийти и забрать её. Если Вы планируете посетить почтовое отделение, полезно было бы знать, насколько целесообразно идти туда в настоящий момент. Тут-то и должен помочь описанный ниже сервис. Итак, варианты использования: 1. Вы хотите прикинуть, насколько целесообразно сейчас идти в конкретное почтовое отделение. Для этого Вы запускаете мобильное приложение, вводите в поле для ввода индекс этого отделения, и на экране показывается информация о примерном количестве человек, среднем времени обслуживания и количестве открытых окошек в отделении. 2. Приходите в почтовое отделение, и, проанализировав ситуацию на участке, запускаете приложение и вводите информацию об отделении: в очереди находится N человек, среднее время обслуживания сейчас M минут, окошек открыто K, и отправляете информацию на сервер. Дальше будут детали реализации. Кому не интересно, можете листать к заключению.

Данные
------

В качестве средства хранения данных используется сервер Redis. Всего используется две базы: в базе под номером 0 хранятся результаты, которые отдаются пользователям; в базу под номером 1 складываются данные от пользователей, именно эти данные усредняются и результаты усреднения помещаются в базу 0. Ключи для значений в базу имеют следующий вид: ZIP:Param, то есть, например, 630064:people-count. Для временных меток - подлиннее - ZIP:Param:timestamp:mega и ZIP:Param:timestamp:second, то есть, например, для того же почтового индекса - 630064:people-count:timestamp:mega и 630064:people-count:timestamp:second. В базе 0 все значения, которые отдаются клиенту, простые, и на них останавливаться не будем. Здесь же хранится множество ZIP'ов, для которых в базе 1 есть новые данные, и которые нужно обновить при случае. В базе 1 для каждого ZIP'а хранятся списки значений от клиентов. На них тоже останавливаться смысла нет. Изначально предполагалось, что в базе Redis'a будут храниться все данные, когда-ли отправленные пользователями. Это было бы полезно, например, для сбора статистики и, возможно, прогнозирования происходящего на участках при отсутствии актуальных данных. После небольших экспериментов, чтения некоторых статей и вопросов-ответов на stackoverflow выяснилось, что это плохая идея, поскольку данные Redis'a очень сильно фрагментированы в памяти. Поэтому списки с "сырыми" данными обрезаются до определённой длины и уничтожаются через определённое время.

Принцип работы
--------------

Серверная часть на данный момент написана целиком на Erlang. Дерево процессов выглядит следующим образом:
![supervision tree](http://habrastorage.org/storage2/d58/b15/271/d58b15271f345ed1f31950d0f44d179e.png)

Краткое описание
----------------

* getters - через них получаем ответ на запрос о том, что происходит на почтовом участке.
* adders добавляют "сырые" данные от пользователей - по одному adder'у для каждого почтового индекса(он же - идентификатор отделения).
* informer служит для получения информации о состоянии данных и для уведомления updater'а о том, что надо бы обновить данные в базе с результатами.
* updater - на основании сырых данных, обновляет данные, предназначенные для пользователя
* getters_sup и adders_sup - supervisor'ы для getter'ов и adder'ов.
* update_event_manager, update_event_handler - служат для отправки обновлённых данных тем, кто их запросил, если во время запроса шло их обновление

При получении запроса, getter сначала выясняет у informer'а, находятся ли требуемые данные в процессе обновления, и, если нет, вытаскивает их и их временные метки, и кладёт это в возвращаемый результат. Если же данные на текущий момент обновляются, создаётся обработчик события, который ожидает окончания этого процесса. adder при получении запроса на добавление просто добавляет данные в "сырую" базу. updater, при получении соответствующего запроса (от informer’a), начинает обновление данных для тех ZIP'ов, для которых, с момента последнего обновления, были получены пользовательские данные. При обновлении данных для очередного ZIP'а, инициируется соответствующее событие, о чём узнаёт event_manager и, через него, соответствующий обработчик события, который отправляет информацию запрашивавшему getter'у посредством gen_server:reply.

Как это работает
----------------

Возможно, из описания выше не совсем понятно, что же происходит, когда пользователь хочет знать (или рассказать), что же творится в почтовом отделении. Расскажу по порядку (не затрагивая при этом как именно передаются данные ноде erlang'а). 

<dl>
  <dt>1. Если пользователь хочет узнать:</dt>
  <dd>* в дерево контроля супервизора getters_sup добавляется новый getter</dd>
  <dd>* этому getter'у посылается синхронный запрос на получение данных о конкретном ZIP'е</dd>
  <dd>* getter узнаёт у informer'а, идёт ли сейчас обновление данных и, если идёт, узнаёт, будут ли обновлены данные для нужного ZIP'а</dd>
  <dd>* если это условие выполняется, создаётся обработчик события, который будет ждать завершения обновления данных для этого ZIP'а и, когда это произойдёт, отправит результат посредством gen_server:reply/2</dd>
  <dd>* если же сейчас нашему ZIP'у обновление не требуется, getter просто берёт данные из базы и отправляет запрашивающему</dd>
  <dt>2. Если пользователь хочет рассказать:</dt>
  <dd>* в дерево контроля супервизора adders_sup добавляется(если его ещё там нет), adder с именем adder<ZIP>, где <ZIP> - почтовый индекс, для которого предполагается добавить информацию</dd>
  <dd>* этому adder'у посылается асинхронный запрос на добавление данных</dd>
</dl>

Описание API
------------

Общение с сервером происходит посредством HTTP. Чтобы получить информацию о ситуации на почтовом участке, необходимо отправить GET-запрос с параметром 'zip', равным почтовому индексу участка. То есть, запрос будет выглядеть так: "http://54.228.208.173:8080/?zip=630064". В ответ приходит строка вида 

```
"people_count:<float-val>:<time>;service_time:<float-val>:<time>;post_windows_count:<float-val>:<time>;package_windows_count:<float-val>:<time>", 
```

где <time> - timestamp, и <float-val> и <time> могут иметь значение 'undefined'. Чтобы сообщить информацию о почтовом участке, посылается POST-запрос, с тем же самым параметром 'zip' и в теле значения для ключей 'people_count', 'service_time', 'post_windows_count' и 'package_windows_count'. То есть, например, на python'e с библиотекой requests POST-запрос может выглядеть так: 

```python
requests.post("http://54.228.208.173:8080/?zip=630064", body = {"people_count": "5", "service_time": "10"})
```

или так: 

```python
requests.post("http://54.228.208.173:8080/", params = {"zip": "630064"}, body = {"people_count": "5", "service_time": "10"}) 
```

В ответ на POST-запрос приходит строка "ok".

Расположение
------------

Сейчас сервер размещён на амазоновском микроинстансе (который бесплатен первый год использования). Понятно, что это далеко не лучший вариант для высоконагруженного сервиса (если он таковым станет), поэтому буду благодарен за любую информацию о доступном хостинге.

Тестирование
------------

Нагрузочное тестирование пытался проводить с помощью утилиты SoapUI. Вот только загвоздка в том, что запускались тесты с одной машины, так что в результате какие-то попугаи получаются. В любом случае, не стоит чего-то особого ожидать от амазоновского микроинстанса, и нормальное тестирование нужно будет проводить, когда сервис будет запущен на соответствующем железе. Сейчас разве что можно как-то прикинуть нагрузку, чтобы подобрать соответствующую конфигурацию сервера.

Клиент
------

В качестве реализации клиента сейчас есть Android-приложение. Главный экран содержит список, в каждом элементе которого отображена информация об одном почтовом отделении.

Информация в элементе
---------------------

1. Почтовый индекс отделения
2. Количество человек в отделении
3. Среднее время обслуживания
4. Общее количество открытых "окошек", в которых что-то выдают/принимают
5. Количество окошек, открытых на выдачу только посылок (редко, но видел такое)

Таким образом, каждый элемент списка содержит информацию примерно такого вида:
<table><tr><td>630064</td><td>9.6</td>  <td>7.5</td>  <td>1.0</td>  <td>N/A</td></tr></table>

На примере количества человек объясню, как предлагается интерпретировать эти числа. Пусть мы обладаем информацией о том, что сейчас в отделении находится 9.6 человека. Будем считать, что там сейчас почти наверняка есть девять человек, и с вероятностью 0.6 есть ещё и десятый. То же самое и с другими вещественными числами: целую часть считаем почти наверняка достоверным количеством чего бы то ни было, а дробная показывает, с какой вероятностью эта величина больше на единицу. "N/A" означает, что данных о величине нет Серый фон под почтовым индексом говорит о том, что в данный момент для него идёт попытка обновления данных. Серый фон под другим элементом показывает, что данные уже неактуальны. Интервал времени, через который данные теряют актуальность, задаётся в настройках. Элементы добавляются в список посредством команды из меню приложения. Удаляются через контекстное меню элемента, появляющееся в результате долгого нажатия на элемент. Из этого же контекстного меню можно обновить данные для выбранного элемента или добавить на сервер данные о том, что творится в конкретном почтовом отделении.

Добавление (отправка) информации
--------------------------------

Экран добавления информации вызывается простым тычком на элемент списка или из контекстного меню элемента. На этом экране в текстовые поля вводим числа, соответствующие количеству человек, времени обслуживания и т.д., подтверждаем введённую информацию соответствующими галочками и нажимаем Send(отправить). Отправляются только подтверждённые данные, так что, если вы не уверены в том, что знаете, сколько времени в среднем обслуживается один человек или понятия не имеете о том, есть ли тут окна, открытые только на выдачу посылок, просто не подтверждайте эти числа.

Известные проблемы (очевидные)
------------------------------

* чтобы это работало, нужно, чтобы этим пользовались (хотя, может и не такая уж это проблема)
* нет никакой идентификации пользователей - просто рай для ботов (хотя слабо себе представляю, зачем это может понадобиться)
* наличие клиента только под андроид, да и то протестированного только на двух моделях - LG P500 и LG P350

Планы на будущее
----------------

<dl>
  <dt>Сервер</dt>
  <dd>документация</dd>
  <dd>возможность запрашивать у сервера информацию о нём (интервал обновления данных, когда было последнее обновление)</dd>
  <dd>добавление средства для долговременного хранения данных - скорей всего, это будет какая-то реляционная БД - в дерево процессов добавится поддерево, полностью дублирующее дерево adders_sup, ибо функции схожи, но желательно всё-таки сделать эти системы независимыми друг от друга</dd>
  <dd>возможно, понадобится средство идентификации пользователей (в качестве защиты от ботов)</dd>
  <dt>Клиент</dt>
  <dd>мобильный клиент под андроид, думаю, будет развиваться по мере увеличения возможностей сервера</dd>
  <dd>было бы неплохо иметь клиенты под все мобильные платформы, но у меня сейчас нет возможности сделать их, так что насчёт этого ничего обещать не могу</dd>
  <dd>сайт; заодно как-никак решилась бы проблема из предыдущего пункта</dd>
</dl>
